// Generated by CoffeeScript 2.3.2
var ActionItem, ActionsList, ConditionItem, ConditionsList, PuzzleInfo, PuzzlesBox, PuzzlesGraph, svgns,
  boundMethodCheck = function(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new Error('Bound instance method accessed before binding'); } };

import {
  Subscriber,
  Container
} from './monitor.js';

import {
  is_empty,
  post_control
} from './monitor.js';

PuzzlesBox = class PuzzlesBox extends Subscriber {
  constructor() {
    super();
    this.apply_template();
    this.shadowRoot.querySelector('#puzzles-menu').onclick = (event) => {
      var game_box;
      game_box = document.querySelector('game-box');
      game_box.current_screen = 'game';
      return game_box.set_screen(game_box.current_screen);
    };
    this.subscribe();
  }

  update(datas) {
    this.set_screen('graph');
    this.update_plugs(datas);
    return this.shadowRoot.querySelector('puzzles-graph').read_items(datas.states);
  }

};

customElements.define('puzzles-box', PuzzlesBox);

svgns = 'http://www.w3.org/2000/svg';

PuzzlesGraph = class PuzzlesGraph extends Container {
  constructor() {
    super();
    this.svg = document.createElementNS(svgns, 'svg');
    this.svg.setAttributeNS(null, 'style', 'width: 100%;');
    this.appendChild(this.svg);
    this.graph = document.createElementNS(svgns, 'g');
    this.graph.setAttributeNS(null, 'style', 'transform: translate(50%, 40px)');
    this.svg.appendChild(this.graph);
  }

  add_item(id, data) {
    var g;
    // check data completeness
    if (!(data.position != null)) {
      console.warn('Incomplete data', data);
      return;
    }
    // create svg shape
    if (data.stype === 'rect') {
      g = this.create_rect(id, data);
    } else if (data.stype === 'circle') {
      g = this.create_circle(id, data);
    } else {
      console.warn('Invalid stype', data.stype);
      return;
    }
    
    // add onclick event
    g.onclick = (event) => {
      var puzzle_info;
      puzzle_info = this.parentNode.parentNode.querySelector('puzzle-info');
      puzzle_info.select(id);
      this.querySelectorAll(".item").forEach((e) => {
        return e.removeAttributeNS(null, 'selected');
      });
      return this.querySelector(`.item[item_id="${id}"]`).setAttributeNS(null, 'selected', '');
    };
    return this.graph.appendChild(g);
  }

  create_circle(id, data) {
    var circle, g, label;
    g = document.createElementNS(svgns, 'g');
    g.setAttributeNS(null, 'class', 'item');
    g.setAttributeNS(null, 'item_id', id);
    circle = document.createElementNS(svgns, 'circle');
    circle.setAttributeNS(null, 'r', 16);
    g.appendChild(circle);
    label = document.createElementNS(svgns, 'text');
    label.classList.add('label');
    label.textContent = 'salut';
    label.setAttributeNS(null, 'text-anchor', 'middle');
    label.setAttributeNS(null, 'x', 0);
    label.setAttributeNS(null, 'y', 32);
    g.appendChild(label);
    return g;
  }

  create_rect(id, data) {
    var g, h, label, mx, my, rect, w, x, xmax, xmin, y, ymax, ymin;
    [xmin, xmax, ymin, ymax] = data.rect_size;
    [mx, my] = data.margin;
    x = -90 * mx - 16;
    y = 70 * (ymin - my);
    w = 90 * (xmax - xmin + 2 * mx) + 16 + 32;
    h = 70 * (ymax - ymin + 2 * my);
    g = document.createElementNS(svgns, 'g');
    g.setAttributeNS(null, 'class', 'item');
    g.setAttributeNS(null, 'item_id', id);
    rect = document.createElementNS(svgns, 'rect');
    rect.setAttributeNS(null, 'x', y);
    rect.setAttributeNS(null, 'y', x);
    rect.setAttributeNS(null, 'width', h);
    rect.setAttributeNS(null, 'height', w);
    g.appendChild(rect);
    label = document.createElementNS(svgns, 'text');
    label.classList.add('label');
    label.textContent = 'salut';
    label.setAttributeNS(null, 'text-anchor', 'start');
    label.setAttributeNS(null, 'x', y + 10);
    label.setAttributeNS(null, 'y', -70 * mx - 24);
    g.appendChild(label);
    return g;
  }

  update_item(id, data) {
    var circle, g, label, x, y;
    // get group
    g = this.get_item(id);
    if (g == null) {
      return;
    }
    // get circle and label
    circle = g.querySelector('circle');
    label = g.querySelector('text');
    // set completed
    if (data['active']) {
      g.setAttributeNS(null, 'active', '');
    } else {
      g.removeAttributeNS(null, 'active');
    }
    // group position
    x = 70 * data['position'][1];
    y = 90 * data['position'][0];
    g.setAttributeNS(null, 'transform', `translate(${x}, ${y})`);
    // set label content
    return label.textContent = data.name;
  }

  onupdated(datas) {
    var box;
    box = this.svg.getBBox();
    this.svg.setAttribute('width', box.x + box.width + box.x);
    return this.svg.setAttribute('height', box.y + box.height + box.y);
  }

};

customElements.define('puzzles-graph', PuzzlesGraph);

PuzzleInfo = class PuzzleInfo extends Subscriber {
  constructor() {
    super();
    this.activate_state = this.activate_state.bind(this);
    this.force_transition = this.force_transition.bind(this);
    this.restore = this.restore.bind(this);
    this.set_active = this.set_active.bind(this);
    this.apply_template();
    this.state = null;
    this.set_screen('empty');
    this.transitions_list = this.shadowRoot.querySelector('#state-transitions');
    this.activate_button = this.shadowRoot.querySelector('#state-activate');
  }

  select(id) {
    return this.subscribe('?id=' + id);
  }

  update(data) {
    var div, name, ref, set_onclick, target_name, trans_name, transition;
    this.update_plugs(data);
    this.activate_button.onclick = (event) => {
      return this.activate_state(data.id);
    };
    this.transitions_list.innerHTML = '';
    ref = data.transitions;
    for (name in ref) {
      transition = ref[name];
      div = document.createElement('div');
      // set target
      target_name = document.createElement('span');
      target_name.innerText = transition.target.name;
      div.appendChild(target_name);
      // set transition name
      trans_name = document.createElement('span');
      trans_name.innerText = transition.name;
      div.appendChild(trans_name);
      // set onclick (hack)
      set_onclick = (trans_id) => {
        return div.onclick = (event) => {
          console.log(trans_id);
          return this.force_transition(trans_id);
        };
      };
      set_onclick(transition.id);
      this.transitions_list.appendChild(div);
    }
    return this.set_screen('info');
  }

  activate_state(state) {
    boundMethodCheck(this, PuzzleInfo);
    return post_control(this.loc, {
      action: 'activate',
      id: state
    });
  }

  force_transition(transition) {
    boundMethodCheck(this, PuzzleInfo);
    return post_control(this.loc, {
      action: 'force_transition',
      id: transition
    });
  }

  restore() {
    boundMethodCheck(this, PuzzleInfo);
    return post_control(this.loc, {
      action: 'restore'
    });
  }

  set_active(state) {
    boundMethodCheck(this, PuzzleInfo);
    return post_control(this.loc, {
      action: 'set_active',
      state: state
    });
  }

};

customElements.define('puzzle-info', PuzzleInfo);

ConditionsList = class ConditionsList extends Container {
  constructor() {
    super();
  }

  add_item(id, data) {
    var item;
    item = this.create_item(id);
    this.appendChild(item);
    return item.shadowRoot.querySelector('condition-item').select(id);
  }

};

customElements.define('conditions-list', ConditionsList);

ConditionItem = class ConditionItem extends Subscriber {
  constructor() {
    super();
    this.force = this.force.bind(this);
    this.restore = this.restore.bind(this);
    this.apply_template();
    this.state = null;
    this.shadowRoot.querySelector('div').querySelector('div').onclick = (event) => {
      return this.force(!this.state);
    };
    this.shadowRoot.querySelector('div').querySelector('button').onclick = (event) => {
      return this.restore();
    };
  }

  select(id) {
    return this.subscribe('?id=' + id);
  }

  update(datas) {
    var button, div;
    this.update_plugs(datas);
    div = this.shadowRoot.querySelector('div');
    button = this.shadowRoot.querySelector('div').querySelector('button');
    this.state = datas['state'];
    if (datas.state == null) {
      div.style.borderColor = 'orange';
    } else if (datas['state']) {
      div.style.borderColor = 'green';
    } else {
      div.style.borderColor = 'red';
    }
    if (datas['forced']) {
      button.disabled = false;
    } else {
      button.disabled = true;
    }
    if (datas['desactivated']) {
      div.disabled = true;
      return div.style.borderColor = 'gray';
    } else {
      return div.disabled = false;
    }
  }

  force(state) {
    boundMethodCheck(this, ConditionItem);
    return post_control(this.loc, {
      action: 'force',
      state: state
    });
  }

  restore() {
    boundMethodCheck(this, ConditionItem);
    return post_control(this.loc, {
      action: 'restore'
    });
  }

};

customElements.define('condition-item', ConditionItem);

ActionsList = class ActionsList extends Container {
  constructor() {
    super();
  }

  add_item(id, data) {
    var item;
    item = this.create_item(id);
    this.appendChild(item);
    return item.shadowRoot.querySelector('action-item').select(id);
  }

};

customElements.define('actions-list', ActionsList);

ActionItem = class ActionItem extends Subscriber {
  constructor() {
    super();
    this.call = this.call.bind(this);
    this.abort = this.abort.bind(this);
    this.apply_template();
    this.shadowRoot.querySelector('div').querySelector('div').onclick = (event) => {
      return this.call();
    };
    this.shadowRoot.querySelector('div').querySelector('button').onclick = (event) => {
      return this.abort();
    };
  }

  select(id) {
    return this.subscribe('?id=' + id);
  }

  update(datas) {
    var div;
    this.update_plugs(datas);
    div = this.shadowRoot.querySelector('div');
    if (datas['running']) {
      div.style.borderColor = 'green';
    } else if (datas['failed']) {
      div.style.borderColor = 'red';
    } else {
      div.style.borderColor = 'orange';
    }
    if (datas['desactivated']) {
      div.disabled = true;
      return div.style.borderColor = 'gray';
    } else {
      return div.disabled = false;
    }
  }

  call() {
    boundMethodCheck(this, ActionItem);
    return post_control(this.loc, {
      action: 'call'
    });
  }

  abort() {
    boundMethodCheck(this, ActionItem);
    return post_control(this.loc, {
      action: 'abort'
    });
  }

};

customElements.define('action-item', ActionItem);
