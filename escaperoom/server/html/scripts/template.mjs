// Generated by CoffeeScript 2.3.2
var boundMethodCheck = function(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new Error('Bound instance method accessed before binding'); } };

export var TemplatedElement = (function() {
  class TemplatedElement extends HTMLElement {
    constructor() {
      super(...arguments);
      this.attributeChangedCallback = this.attributeChangedCallback.bind(this);
    }

    instantiate_template(template, use_shadow = false) {
      var first_child, i, len, new_element, slot, slotname, slots;
      new_element = template.content.cloneNode(true);
      first_child = new_element.firstElementChild;
      if (!use_shadow) {
        return first_child;
      }
      // create all plugs
      // TODO use '> slot'
      slots = template.content.querySelectorAll('slot');
      slots = (function() {
        var i, len, results;
        results = [];
        for (i = 0, len = slots.length; i < len; i++) {
          slot = slots[i];
          results.push(slot.getAttribute('name'));
        }
        return results;
      })();
      for (i = 0, len = slots.length; i < len; i++) {
        slotname = slots[i];
        first_child.insertBefore(this.create_plug(slotname), first_child.childNodes[0]);
      }
      return first_child;
    }

    create_plug(slotname) {
      var span;
      span = document.createElement('span');
      span.setAttribute('slot', slotname);
      return span;
    }

    fill_slots(item, data, use_shadow = false) {
      var i, j, len, len1, name, ref, ref1, results, results1, slot;
      if (use_shadow) {
        ref = this.shadowRoot.querySelectorAll('slot');
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          slot = ref[i];
          name = slot.getAttribute('name');
          slot = dest.querySelector(`*[slot='${name}']`);
          if (slot != null) {
            if (typeof data[name] === 'object') {
              results.push(slot.textContent = JSON.stringify(data[name], null, ' '));
            } else {
              results.push(slot.textContent = data[name]);
            }
          } else {
            results.push(void 0);
          }
        }
        return results;
      } else {
        ref1 = item.querySelectorAll('slot');
        results1 = [];
        for (j = 0, len1 = ref1.length; j < len1; j++) {
          slot = ref1[j];
          name = slot.getAttribute('name');
          if (typeof data[name] === 'object') {
            results1.push(slot.innerText = JSON.stringify(data[name], null, ' '));
          } else {
            results1.push(slot.innerText = data[name]);
          }
        }
        return results1;
      }
    }

    attributeChangedCallback(name, old_value, new_value) {
      boundMethodCheck(this, TemplatedElement);
    }

  };

  Object.defineProperty(TemplatedElement, 'observedAttributes', {
    get: () => {
      return [];
    }
  });

  return TemplatedElement;

}).call(this);
