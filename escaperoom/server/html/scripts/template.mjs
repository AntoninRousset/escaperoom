// Generated by CoffeeScript 2.3.2
export var TemplatedElement = class TemplatedElement extends HTMLElement {
  apply_template(template, dest, use_shadow = false) {
    var first_child, i, len, new_element, slot, slotname, slots;
    new_element = template.content.cloneNode(true);
    first_child = new_element.firstElementChild;
    if (!use_shadow) {
      dest.appendChild(new_element);
      return first_child;
    }
    dest.attachShadow({
      mode: 'open'
    });
    dest.shadowRoot.appendChild(new_element);
    // create all plugs
    // TODO use '> slot'
    slots = template.content.querySelectorAll('slot');
    slots = (function() {
      var i, len, results;
      results = [];
      for (i = 0, len = slots.length; i < len; i++) {
        slot = slots[i];
        results.push(slot.getAttribute('name'));
      }
      return results;
    })();
    for (i = 0, len = slots.length; i < len; i++) {
      slotname = slots[i];
      first_child.insertBefore(this.create_plug(slotname), first_child.childNodes[0]);
    }
    return first_child;
  }

  create_plug(slotname) {
    var span;
    span = document.createElement('span');
    span.setAttribute('slot', slotname);
    return span;
  }

  update_item(item, data, use_shadow = false) {
    var i, j, len, len1, name, ref, ref1, results, results1, slot;
    data = this.custom_update(item, data);
    if (use_shadow) {
      ref = this.shadowRoot.querySelectorAll('slot');
      results = [];
      for (i = 0, len = ref.length; i < len; i++) {
        slot = ref[i];
        name = slot.getAttribute('name');
        slot = dest.querySelector(`*[slot='${name}']`);
        if (slot != null) {
          results.push(slot.textContent = data[name]);
        } else {
          results.push(void 0);
        }
      }
      return results;
    } else {
      ref1 = item.querySelectorAll('slot');
      results1 = [];
      for (j = 0, len1 = ref1.length; j < len1; j++) {
        slot = ref1[j];
        name = slot.getAttribute('name');
        results1.push(slot.innerText = data[name]);
      }
      return results1;
    }
  }

  // Used for custom item updating. The returned data is used for slot filling.
  // If null is returned, no extra item update is performed.
  custom_update(item, data) {
    return data;
  }

};
