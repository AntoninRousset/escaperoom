// Generated by CoffeeScript 2.3.2
var boundMethodCheck = function(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new Error('Bound instance method accessed before binding'); } };

import {
  FetchedElement
} from './fetch.mjs';

export var SyncedElement = (function() {
  var event_source, subscriptions;

  class SyncedElement extends FetchedElement {
    constructor(data_type, emul_slow) {
      super(data_type, emul_slow);
      this.disconnectedCallback = this.disconnectedCallback.bind(this);
      this.onsyncevent = this.onsyncevent.bind(this);
      this.onnewdata = this.onnewdata.bind(this);
      this.attributeChangedCallback = this.attributeChangedCallback.bind(this);
      this.postponed_syncevents = [];
    }

    disconnectedCallback() {
      boundMethodCheck(this, SyncedElement);
      return this.unsubscribe();
    }

    subscribe(filter) {
      if (typeof filter === 'string') {
        return subscriptions.push([
          this,
          (event) => {
            return event.src === filter;
          }
        ]);
      } else if (typeof filter === 'function') {
        return subscriptions.push([this, filter]);
      } else {
        return log.error('Invalid filter', filter);
      }
    }

    unsubscribe() {
      return subscriptions = subscriptions.filter((x) => {
        return x[0] === !this;
      });
    }

    onsyncevent(event) {
      boundMethodCheck(this, SyncedElement);
      // if paused, add event to be retriggered once not paused anymore
      if (this.hasAttribute('paused')) {
        return this.postponed_syncevents.push(event);
      }
      // load new content
      if (this.src != null) {
        return this.load_from(this.src);
      } else {
        return this.set_screen('empty');
      }
    }

    onnewdata(data) {
      boundMethodCheck(this, SyncedElement);
      this.fill_slots(this, data);
      return this.set_screen('main');
    }

    attributeChangedCallback(name, old_value, new_value) {
      var event, i, len, postponed_syncevents, results;
      boundMethodCheck(this, SyncedElement);
      super.attributeChangedCallback(name, old_value, new_value);
      // change in the event subscription
      if (name === 'src' || name === 'eventsrc' || name === 'eventtype') {
        if (!this.hasAttribute('eventsrc') && !this.hasAttribute('eventtype')) {
          this.subscribe(this.src);
        } else {
          this.subscribe((event) => {
            if (this.hasAttribute('eventsrc') && event.src !== this.getAttribute('eventsrc')) {
              return false;
            }
            if (this.hasAttribute('eventtype') && !event.type.join('.').startsWith(this.getAttribute('eventtype'))) {
              return false;
            }
            return true;
          });
        }
      }
      // paused
      if (name === 'paused') {
        // if not paused anymore, trigger buffered syncevent
        if (new_value == null) {
          // postponed_syncevents array is copied to allow @onsyncevent
          // to modify it
          postponed_syncevents = this.postponed_syncevents.slice();
          this.postponed_syncevents = [];
          results = [];
          for (i = 0, len = postponed_syncevents.length; i < len; i++) {
            event = postponed_syncevents[i];
            results.push(this.onsyncevent(event));
          }
          return results;
        }
      }
    }

  };

  subscriptions = [];

  event_source = new EventSource('events');

  event_source.onmessage = function(event) {
    var data, event_src, filter, i, len, results, sub, subscriber;
    data = JSON.parse(event.data);
    if (data['type'] === 'update') {
      event_src = data['src'];
    }
    results = [];
    for (i = 0, len = subscriptions.length; i < len; i++) {
      sub = subscriptions[i];
      subscriber = sub[0];
      filter = sub[1];
      if (filter(data)) {
        results.push(subscriber.onsyncevent(event));
      } else {
        results.push(void 0);
      }
    }
    return results;
  };

  Object.defineProperty(SyncedElement, 'observedAttributes', {
    get: () => {
      return FetchedElement.observedAttributes.concat(['eventsrc', 'eventtype', 'paused']);
    }
  });

  return SyncedElement;

}).call(this);

customElements.define('synced-element', SyncedElement);
