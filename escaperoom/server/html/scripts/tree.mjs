// Generated by CoffeeScript 2.3.2
var collator,
  boundMethodCheck = function(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new Error('Bound instance method accessed before binding'); } },
  indexOf = [].indexOf;

import {
  SyncedContainer
} from './container.mjs';

import {
  is_empty
} from './utils.mjs';

collator = new Intl.Collator(void 0, {
  numeric: true,
  sensitivity: 'base'
});

export var SyncedTree = class SyncedTree extends SyncedContainer {
  constructor() {
    super();
    this.connectedCallback = this.connectedCallback.bind(this);
    this.onnewdata = this.onnewdata.bind(this);
    this.sort_data = this.sort_data.bind(this);
    this.create_item = this.create_item.bind(this);
    this.onbeforeelementupdated = this.onbeforeelementupdated.bind(this);
    this.setup_row_selection = this.setup_row_selection.bind(this);
    this.classList.add('tree');
  }

  connectedCallback() {
    boundMethodCheck(this, SyncedTree);
    this.src = this.getAttribute('src');
    return super.connectedCallback();
  }

  onnewdata(data) {
    var i, item, j, key, len, len1, newbody, ref, ref1, template;
    boundMethodCheck(this, SyncedTree);
    newbody = document.createElement('div');
    newbody.classList.add('body');
    ref = this.body.querySelectorAll('template');
    // copy templates
    for (i = 0, len = ref.length; i < len; i++) {
      template = ref[i];
      newbody.appendChild(template.cloneNode(true));
    }
    ref1 = this.sort_data(data.children);
    for (j = 0, len1 = ref1.length; j < len1; j++) {
      key = ref1[j];
      item = this.create_item(data.children[key]);
      newbody.appendChild(item);
    }
    return this.body = newbody;
  }

  sort_data(data) {
    boundMethodCheck(this, SyncedTree);
    return Object.keys(data).sort(collator.compare);
  }

  create_item(data) {
    var btn, extra, i, item, j, k, key, l, len, len1, len2, len3, ref, ref1, ref2, ref3, template;
    boundMethodCheck(this, SyncedTree);
    template = this.body.querySelector('template.normalrow');
    item = this.instantiate_template(template);
    item.setAttribute('item_id', data.key);
    this.fill_slots(item, data);
    this.setup_row_selection(item);
    ref = item.querySelectorAll('stamp-switch.foldswitch');
    // add foldswitch action
    for (i = 0, len = ref.length; i < len; i++) {
      btn = ref[i];
      btn.onstatechange = this.foldswitch_onstatechange;
    }
    ref1 = item.querySelectorAll('stamp-button.create');
    // add create item action
    for (j = 0, len1 = ref1.length; j < len1; j++) {
      btn = ref1[j];
      btn.action = this.button_create_action;
    }
    ref2 = item.querySelectorAll('stamp-button.delete');
    // add delete item action
    for (k = 0, len2 = ref2.length; k < len2; k++) {
      btn = ref2[k];
      btn.action = this.button_delete_action;
    }
    extra = item.querySelector('*.children');
    ref3 = this.sort_data(data.children);
    for (l = 0, len3 = ref3.length; l < len3; l++) {
      key = ref3[l];
      extra.appendChild(this.create_item(data.children[key]));
    }
    if (!is_empty(data.children)) {
      item.classList.add('foldable');
    }
    if (this.custom_item_modification != null) {
      item = this.custom_item_modification(item, data);
    }
    return item;
  }

  onbeforeelementupdated(from_element, to_element) {
    boundMethodCheck(this, SyncedTree);
    // skip if customElement
    if (from_element.classList.contains('stamp')) {
      return false;
    }
    if (from_element.classList.contains('row')) {
      // keep row open
      if (from_element.hasAttribute('open')) {
        to_element.setAttribute('open', '');
      }
      // keep row selected
      if (from_element.hasAttribute('selected')) {
        return to_element.setAttribute('selected', '');
      }
    }
  }

  setup_row_selection(row) {
    var rowcontent;
    boundMethodCheck(this, SyncedTree);
    // add selection action (on the row itself not the children)
    rowcontent = row.querySelector(':scope > div:not(.children)');
    return rowcontent.addEventListener('click', (event) => {
      var i, len, r, ref;
      if (indexOf.call(row.classList, 'selectable') < 0) {
        return;
      }
      ref = this.body.querySelectorAll('.row');
      for (i = 0, len = ref.length; i < len; i++) {
        r = ref[i];
        if (r === row) {
          if (!r.hasAttribute('selected')) {
            (this.onrowselect != null) && this.onrowselect(r);
            r.setAttribute('selected', '');
          }
        } else {
          if (r.hasAttribute('selected')) {
            (this.onrowunselect != null) && this.onrowunselect(r);
            r.removeAttribute('selected');
          }
        }
      }
      return event.stopPropagation();
    });
  }

  foldswitch_onstatechange() {
    var row;
    row = this.closest('.row');
    if (this.getAttribute('state') === 'on') {
      return row.setAttribute('open', '');
    } else {
      return row.removeAttribute('open');
    }
  }

  button_create_action() {
    var children, creationrow, input, row, template, tree;
    row = this.closest('.row');
    tree = row.closest('synced-tree');
    children = row.querySelector('.children');
    template = tree.body.querySelector('template.creationrow');
    creationrow = tree.instantiate_template(template);
    children.appendChild(creationrow);
    row.classList.add('foldable');
    row.querySelector('stamp-switch.foldswitch').setAttribute('state', 'on');
    input = row.querySelector('*[contenteditable]');
    input.addEventListener('keydown', async(event) => {
      var content, etcd_key, item_id, ref, response;
      // prevent illegal characters
      if ((ref = event.key) === '*' || ref === ',') {
        event.preventDefault();
      }
      if (event.key === 'Escape') {
        input.blur();
      }
      if (event.key === 'Enter') {
        event.preventDefault();
        content = input.innerText.trim();
        if (!content) {
          return;
        }
        item_id = row.getAttribute('item_id');
        etcd_key = `${item_id}/${content}`;
        response = (await fetch('etcd' + etcd_key, {
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify(null),
          method: 'PUT'
        }));
      }
      return tree.removeAttribute('paused');
    });
    input.addEventListener('focus', (event) => {
      return tree.setAttribute('paused', '');
    });
    input.addEventListener('blur', (event) => {
      tree.onnewdata(tree.data);
      return tree.removeAttribute('paused');
    });
    return input.focus();
  }

  async button_delete_action(event) {
    var etcd_key, item_id, response, row;
    row = this.closest('.row');
    item_id = row.getAttribute('item_id');
    etcd_key = `${item_id}/**`;
    response = (await fetch('etcd' + etcd_key, {
      headers: {
        'Content-Type': 'application/json'
      },
      method: 'DELETE'
    }));
    return console.log('DELETE', response);
  }

};

customElements.define('synced-tree', SyncedTree);
