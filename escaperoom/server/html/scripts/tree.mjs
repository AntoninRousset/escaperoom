// Generated by CoffeeScript 2.3.2
var collator,
  boundMethodCheck = function(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new Error('Bound instance method accessed before binding'); } };

import {
  SyncedContainer
} from './container.mjs';

import {
  is_empty
} from './utils.mjs';

collator = new Intl.Collator(void 0, {
  numeric: true,
  sensitivity: 'base'
});

export var SyncedTree = class SyncedTree extends SyncedContainer {
  constructor() {
    super();
    this.connectedCallback = this.connectedCallback.bind(this);
    this.onnewdata = this.onnewdata.bind(this);
    this.sort_data = this.sort_data.bind(this);
    this.create_item = this.create_item.bind(this);
    this.onBeforeElementUpdated = this.onBeforeElementUpdated.bind(this);
    this.classList.add('tree');
  }

  connectedCallback() {
    boundMethodCheck(this, SyncedTree);
    this.src = this.getAttribute('src');
    return super.connectedCallback();
  }

  onnewdata(data) {
    var i, item, key, len, newbody, ref, template;
    boundMethodCheck(this, SyncedTree);
    newbody = document.createElement('div');
    newbody.classList.add('body');
    // copy template
    template = this.body.querySelector('template');
    newbody.appendChild(template.cloneNode(true));
    ref = this.sort_data(data.children);
    for (i = 0, len = ref.length; i < len; i++) {
      key = ref[i];
      item = this.create_item(data.children[key]);
      newbody.appendChild(item);
    }
    return this.body = newbody;
  }

  sort_data(data) {
    boundMethodCheck(this, SyncedTree);
    return Object.keys(data).sort(collator.compare);
  }

  create_item(data) {
    var btn, expand, extra, i, item, j, k, key, len, len1, len2, ref, ref1, ref2, template;
    boundMethodCheck(this, SyncedTree);
    template = this.body.querySelector('template');
    item = this.instantiate_template(template);
    item.setAttribute('item_id', data.key);
    ref = item.querySelectorAll('stamp-switch.foldswitch');
    // add foldswitch action
    for (i = 0, len = ref.length; i < len; i++) {
      btn = ref[i];
      btn.onstatechange = function() {
        var row;
        row = this.closest('.row');
        if (this.getAttribute('state') === 'on') {
          return row.setAttribute('open', '');
        } else {
          return row.removeAttribute('open');
        }
      };
    }
    this.fill_slots(item, data);
    if (!is_empty(data.children)) {
      ref1 = item.querySelectorAll('.expand');
      for (j = 0, len1 = ref1.length; j < len1; j++) {
        expand = ref1[j];
        expand.addEventListener('click', toggle_row_expand);
      }
    }
    extra = item.querySelector('*.children');
    ref2 = this.sort_data(data.children);
    for (k = 0, len2 = ref2.length; k < len2; k++) {
      key = ref2[k];
      extra.appendChild(this.create_item(data.children[key]));
    }
    if (!is_empty(data.children)) {
      item.classList.add('foldable');
    }
    if (this.custom_item_modification != null) {
      item = this.custom_item_modification(item, data);
    }
    return item;
  }

  onBeforeElementUpdated(from_element, to_element) {
    boundMethodCheck(this, SyncedTree);
    // skip if customElement
    if (from_element.classList.contains('stamp')) {
      return false;
    }
    if (from_element.classList.contains('row')) {
      // keep row open
      if (from_element.hasAttribute('open')) {
        to_element.setAttribute('open', '');
      }
      // keep row selected
      if (from_element.hasAttribute('selected')) {
        return to_element.setAttribute('selected', '');
      }
    }
  }

};

customElements.define('synced-tree', SyncedTree);
