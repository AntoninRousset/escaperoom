// Generated by CoffeeScript 2.3.2
var dom_parser, sleep,
  boundMethodCheck = function(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new Error('Bound instance method accessed before binding'); } };

dom_parser = new DOMParser();

// TODO to remove, only here to emulate bandwidth limitation
sleep = function(ms) {
  return new Promise(function(resolve) {
    return setTimeout(resolve, ms);
  });
};

export var post_control = async function(loc, data) {
  var datas, response;
  response = (await fetch(loc, {
    headers: {
      'Content-Type': 'application/json'
    },
    body: JSON.stringify(data),
    method: 'POST'
  }));
  datas = (await response.json());
  if (datas.state === 'failed') {
    if (datas.reason != null) {
      throw 'failed to post control: ' + datas.reason;
    } else {
      throw 'failed to post control';
    }
  }
  return datas.data;
};

export var fetch_html = async function(url, slow = false) {
  var resp;
  resp = (await fetch(url, {
    mehtod: 'GET'
  }));
  if (slow) {
    await sleep(Math.floor(Math.random() * 3000));
  }
  if (!resp.ok) {
    console.warn('Failed to fetch', url);
    return null;
  }
  return dom_parser.parseFromString((await resp.text()), 'text/html');
};

export var Subscriber = (function() {
  var event_handler, event_source, subscribers;

  class Subscriber extends HTMLElement {
    constructor() {
      super();
      this.subscribe = this.subscribe.bind(this);
      this.sync = this.sync.bind(this);
      this.onloading = this.onloading.bind(this);
      this.onsuccess = this.onsuccess.bind(this);
      this.onerror = this.onerror.bind(this);
      this.loc = '';
      this.classList.add('loadable');
    }

    subscribe(loc1) {
      var event_path;
      boundMethodCheck(this, Subscriber);
      this.loc = loc1;
      // be sure to be unsubscribed first
      this.unsubscribe();
      event_path = this.loc.substring(0, this.loc.lastIndexOf('/')) + '/events';
      if (event_source == null) {
        event_source = new EventSource(event_path);
      }
      subscribers.push(this);
      event_source.onmessage = event_handler;
      return this.sync();
    }

    async sync() {
      var data, loading_timeout, now, response;
      boundMethodCheck(this, Subscriber);
      now = new Date();
      this.now = now;
      loading_timeout = setTimeout(this.onloading, 1000);
      response = (await fetch(this.loc));
      data = (await response.json());
      clearTimeout(loading_timeout);
      if (now === this.now) {
        return this.update(data);
      }
    }

    unsubscribe() {
      var i, results, subscriber;
      results = [];
      for (i in subscribers) {
        subscriber = subscribers[i];
        if (this === subscriber) {
          results.push(subscribers.splice(i, 1));
        } else {
          results.push(void 0);
        }
      }
      return results;
    }

    update(data) {
      return console.warn('Uncatched update');
    }

    onloading() {
      boundMethodCheck(this, Subscriber);
      return this.setAttribute('loading', '');
    }

    onsuccess() {
      boundMethodCheck(this, Subscriber);
      this.removeAttribute('loading');
      return this.removeAttribute('error');
    }

    onerror() {
      boundMethodCheck(this, Subscriber);
      return this.setAttribute('error', '');
    }

  };

  event_source = null;

  subscribers = [];

  event_handler = function(event) {
    var data, j, len, loc, results, subscriber;
    console.log('-- event -->', event);
    data = JSON.parse(event.data);
// inform all id corresponding subscribers
    results = [];
    for (j = 0, len = subscribers.length; j < len; j++) {
      subscriber = subscribers[j];
      if (data['type'] === 'update') {
        loc = data['url'];
        if ('id' in data) {
          loc = loc + '?id=' + data['id'];
        }
        if (subscriber.loc === loc) {
          results.push(subscriber.sync());
        } else {
          results.push(void 0);
        }
      } else {
        results.push(void 0);
      }
    }
    return results;
  };

  return Subscriber;

}).call(this);
