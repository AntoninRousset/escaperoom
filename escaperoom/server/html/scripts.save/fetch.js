// Generated by CoffeeScript 2.3.2
var dom_parser, sleep,
  boundMethodCheck = function(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new Error('Bound instance method accessed before binding'); } };

import {
  MultiScreenElement
} from './screen.js';

dom_parser = new DOMParser();

// TODO to remove, only here to emulate bandwidth limitation
sleep = function(ms) {
  return new Promise(function(resolve) {
    return setTimeout(resolve, ms);
  });
};

export var fetch_data = async function(url, data_type, emul_slow = false) {
  var resp;
  resp = (await fetch(url, {
    method: 'GET'
  }));
  if (emul_slow) {
    await sleep(Math.floor(Math.random() * 3000));
  }
  if (!resp.ok) {
    console.error('Failed to fetch', url);
    return null;
  }
  if (data_type === 'json') {
    return JSON.parse((await resp.text()));
  } else if (data_type === 'text') {
    return (await resp.text());
  } else if (data_type === 'html') {
    return resp.text().then(function(text) {
      return dom_parser.parseFromString(text, 'text/html');
    });
  } else {
    return console.error(`Invalid data_type ${data_type} during fetching`);
  }
};

export var FetchedElement = class FetchedElement extends MultiScreenElement {
  constructor(src = null, data_type1 = 'json', emul_slow1 = false) {
    super('loading');
    this.onnewdata = this.onnewdata.bind(this);
    this.load_from_src = this.load_from_src.bind(this);
    this.load_from = this.load_from.bind(this);
    this.src = src;
    this.data_type = data_type1;
    this.emul_slow = emul_slow1;
    this._data = null;
    Object.defineProperty(this, "data", {
      get: function() {
        return this._data;
      },
      set: function(data) {
        this.onnewdata(data);
        return this._data = data;
      }
    });
  }

  onnewdata(data) {
    boundMethodCheck(this, FetchedElement);
    return console.warn('Unused data', data);
  }

  async load_from_src() {
    boundMethodCheck(this, FetchedElement);
    return (await this.load_from(this.src));
  }

  async load_from(url) {
    var loading_timeout, now;
    boundMethodCheck(this, FetchedElement);
    now = new Date();
    this.now = now;
    loading_timeout = setTimeout(this.onloading, 1000);
    this.data = (await fetch_data(url, this.data_type, this.emul_slow));
    clearTimeout(loading_timeout);
    if (now === this.now) {
      return this.data = data;
    }
  }

};

export var SubscribedElement = (function() {
  var event_source, subscribers;

  class SubscribedElement extends FetchedElement {
    constructor() {
      super(...arguments);
      this.connectCallback = this.connectCallback.bind(this);
    }

    connectCallback() {
      boundMethodCheck(this, SubscribedElement);
      super.connectCallback();
      return this.subscribe(this.src);
    }

    subscribe() {
      // avoid subscribing twice
      this.unsubscribe();
      return subscribers.push(this);
    }

  };

  subscribers = [];

  event_source = new EventSource('events');

  event_source.onmessage = function(event) {
    var data, i, len, loc, results, subscriber;
    data = JSON.parse(event.data);
    if (data['type'] === 'update') {
      loc = data['url'];
      if ('id' in data) {
        loc = loc + '?id=' + data['id'];
      }
    }
    results = [];
    for (i = 0, len = subscribers.length; i < len; i++) {
      subscriber = subscribers[i];
      if (subscriber.loc === loc) {
        results.push(subscriber.load_from_src());
      } else {
        results.push(void 0);
      }
    }
    return results;
  };

  return SubscribedElement;

}).call(this);
