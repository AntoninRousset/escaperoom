// Generated by CoffeeScript 2.3.2
var Templated,
  boundMethodCheck = function(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new Error('Bound instance method accessed before binding'); } },
  indexOf = [].indexOf;

export var is_empty = function(obj) {
  var key;
  for (key in obj) {
    return false;
  }
  return true;
};

Templated = class Templated extends HTMLElement {
  constructor() {
    var slot, slots;
    super();
    this.template = this.querySelector('template');
    if (this.template != null) {
      slots = this.template.content.querySelectorAll('slot');
      this.slots = (function() {
        var j, len, results;
        results = [];
        for (j = 0, len = slots.length; j < len; j++) {
          slot = slots[j];
          results.push(slot.getAttribute('name'));
        }
        return results;
      })();
    }
  }

  apply_template(node = this) {
    var j, len, ref, slot;
    if (this.template.hasAttribute('class')) {
      node.setAttribute('class', this.template.getAttribute('class'));
    }
    ref = this.slots;
    for (j = 0, len = ref.length; j < len; j++) {
      slot = ref[j];
      node.appendChild(this.create_plug(slot));
    }
    node.attachShadow({
      mode: 'open'
    });
    node.shadowRoot.appendChild(this.template.content.cloneNode(true));
    return node;
  }

  create_plug(slot) {
    var span;
    span = document.createElement('span');
    span.setAttribute('slot', slot);
    return span;
  }

  update_plugs(data, node = this) {
    var j, len, ref, results, slot;
    ref = this.slots;
    results = [];
    for (j = 0, len = ref.length; j < len; j++) {
      slot = ref[j];
      results.push(this.update_plug(slot, data, node));
    }
    return results;
  }

  update_plug(slot, data, node) {
    node = node.querySelector('[slot=' + slot + ']');
    return node.textContent = data[slot];
  }

  set_screen(name, node = this) {
    var j, len, ref, results, screen;
    ref = node.shadowRoot.querySelectorAll('.screen');
    results = [];
    for (j = 0, len = ref.length; j < len; j++) {
      screen = ref[j];
      if (screen.getAttribute('name') === name) {
        results.push(screen.removeAttribute('hidden'));
      } else {
        results.push(screen.setAttribute('hidden', ''));
      }
    }
    return results;
  }

  has_screen(name, node = this) {
    if (node.shadowRoot == null) {
      return false;
    }
    return node.shadowRoot.querySelector('.screen[name="' + name + '"]') != null;
  }

  get_screen(node = this) {
    return this.shadowRoot.querySelector('.screen:not([hidden])');
  }

};

export var Subscriber = (function() {
  var event_handler, event_source, subscribers;

  class Subscriber extends Templated {
    constructor() {
      super();
      this.sync = this.sync.bind(this);
      this.onloading = this.onloading.bind(this);
      this.onerror = this.onerror.bind(this);
      this.loc = '';
    }

    subscribe(query_str = '', path = null) {
      var event_path;
      if (path != null) {
        path = this.setAttribute('src', path);
      } else {
        path = this.getAttribute('src');
      }
      this.unsubscribe();
      this.loc = path + query_str;
      event_path = path.substring(0, path.lastIndexOf('/')) + '/events';
      if (event_source == null) {
        event_source = new EventSource(event_path);
      }
      subscribers.push(this);
      event_source.onmessage = event_handler;
      return this.sync();
    }

    async sync() {
      var data, loading_timeout, now, response;
      boundMethodCheck(this, Subscriber);
      now = new Date();
      this.now = now;
      loading_timeout = setTimeout(this.onloading, 1000);
      response = (await fetch(this.loc));
      data = (await response.json());
      clearTimeout(loading_timeout);
      if (now === this.now) {
        return this.update(data);
      }
    }

    onloading(promise) {
      boundMethodCheck(this, Subscriber);
      if (this.has_screen('loading')) {
        return this.set_screen('loading');
      }
    }

    onerror() {
      boundMethodCheck(this, Subscriber);
      if (this.has_screen('error')) {
        return this.set_screen('error');
      }
    }

    unsubscribe() {
      var i, results, subscriber;
      results = [];
      for (i in subscribers) {
        subscriber = subscribers[i];
        if (this === subscriber) {
          results.push(subscribers.splice(i, 1));
        } else {
          results.push(void 0);
        }
      }
      return results;
    }

    update(datas) {
      return this.update_plugs(datas);
    }

  };

  event_source = null;

  subscribers = [];

  event_handler = function(event) {
    var data, j, len, results, subscriber;
    data = JSON.parse(event.data);
    results = [];
    for (j = 0, len = subscribers.length; j < len; j++) {
      subscriber = subscribers[j];
      if (data['type'] === 'update' && data['loc'] === subscriber.loc) {
        results.push(subscriber.sync());
      } else {
        results.push(void 0);
      }
    }
    return results;
  };

  return Subscriber;

}).call(this);

export var Container = class Container extends Templated {
  constructor() {
    super();
  }

  create_item(id, type = 'div') {
    var item;
    item = document.createElement(type);
    item.setAttribute('item_id', id);
    return this.apply_template(item);
  }

  update_item(id, data) {
    var item;
    item = this.get_item(id);
    return this.update_plugs(data, item);
  }

  read_items(datas) {
    var data, id, j, len, ref;
    ref = this.items_ids();
    for (j = 0, len = ref.length; j < len; j++) {
      id = ref[j];
      if (!(id in datas)) {
        this.remove_item(id);
      }
    }
    for (id in datas) {
      data = datas[id];
      if (indexOf.call(this.items_ids(), id) < 0) {
        this.add_item(id, data);
      }
      this.update_item(id, data);
    }
    if (is_empty(datas) && (this.onempty != null)) {
      return this.onempty();
    }
  }

  items_ids() {
    var item, items, j, len, results;
    items = this.querySelectorAll('.item:not(template)');
    results = [];
    for (j = 0, len = items.length; j < len; j++) {
      item = items[j];
      results.push(item.getAttribute('item_id'));
    }
    return results;
  }

  get_item(id) {
    var selector;
    selector = '.item[item_id="' + id + '"]:not(template)';
    return this.querySelector(selector);
  }

  remove_item(id) {
    return this.get_item(id).remove();
  }

};
